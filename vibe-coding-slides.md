# Mastering AI-Powered Development: A Comprehensive Guide to Coding Agents



---

# VIBE CODING BASICS

## 1. Prompts


### Three Types of Prompts:

**Global Prompts:** Automatically added to every chat
- Project standards and team conventions
- System patterns (MVC, microservices)
- Domain knowledge (banking, healthcare)

**Predefined Prompts:** Custom commands for efficiency
- Language-specific instructions
- Workflow automation
- Quality checklists

**Ad-hoc Prompts:** Real-time context
- Chat messages
- Code files and folders
- Documentation links

---

## 2. Support Multiple LLMs


### Popular Models:
- **Claude Sonnet 3.7/4.0** - Complex architecture & code relationships
- **Gemini 2.5 Pro** - Visual design to code, fast prototyping
- **GPT 4.1** - Reliable everyday development tasks

### Why Multiple LLMs?
- Cross-check plans and validate code
- Get different perspectives
- Increase confidence in solutions

---

## 3. Agent Mode


### Plan Mode üß† - Think First
- System design and architecture
- Component dependencies
- Risk assessment
- **No code execution** - pure planning

### Action Mode ‚ö° - Build It
- Code generation and modification
- File operations
- Command execution
- Testing and validation

### Key Rule: Plan ‚Üí Action (finish planning before building)

---

## 4. Context Management


### Two Strategies:
- **Clear Context** - Fresh start for new features
- **Compress Context** - Maintain continuity, optimize performance

### Best Practice:
Longer context ‚â† better results. Compress regularly for speed and cost efficiency.

---

# VIBE CODING ADVANCED

## 5. AI Strengths


### Where Agents Excel ‚úÖ
1. **Prototypes** - Quick demos (not production-ready)
2. **Known Algorithms** - Well-documented patterns
3. **Template Code** - Similar features from examples
4. **Unit Tests** - Comprehensive test coverage

---

## 6. AI Limitations


### Where Agents Struggle ‚ö†Ô∏è
1. **Big Picture** - Adding features without system understanding
2. **Consistency** - Different patterns across modules
3. **Duplicate Code** - Missing existing functionality
4. **Library Choices** - Unexpected dependencies

---

## 7. New Development Flow


### Developer-Led Process:
1. **Design System** - Create project blueprint
2. **Break Down Tasks** - Smaller, manageable pieces
3. **Design Tests** - Define success criteria
4. **Review & Refactor** - Ensure consistency
5. **Update Docs** - Keep knowledge current

---

## 8. Memory Banks


### Three Components:
- **Project Brief üìã** - Requirements, use cases, success metrics
- **System Patterns üèóÔ∏è** - Architecture, data flow, file structure
- **Technical Context üîß** - Libraries, dependencies, environment

### Why Memory Banks?
Persistent project knowledge across sessions - no need to re-explain every time.

---

## 9. Task Management


### Combined Plan + Action Flow:
1. Take PRD ‚Üí Create focused task
2. Refine task through conversation (Plan Mode)
3. Execute when ready (Action Mode)
4. Review and update docs

### Key Insight: 
**Don't build long task lists** - Short lists are more reliable and flexible.

---

## 10. Tips


### Battle-Tested Rules:
1. **3-Strike Rule** - Change approach after 3 failures
2. **10-Message Rule** - Compress/clear context regularly
3. **Be Specific** - "Page crashes on refresh" vs "UI doesn't work"
4. **Version Control** - Commit after each success
5. **Last Resort** - Sometimes start fresh

---

# VIBE CODING TOOLS

## 11. MCP Servers


### Key Integrations:
- **Figma** - Design to code automatically
- **JIRA** - Tickets to tasks
- **Context7** - Latest documentation
- **StageWise** - Browser to editor connection

---

## 12. Best Coding Agents


### Top Platforms:

**Claude Code:**
- Built-in task breakdown
- `/clear` and `/compact` commands

**Roo Code:**
- Automatic context compression
- Cost-efficient and fast
